#!/system/bin/sh

################################################################################
#                                                                              #
#   üöÄ ANDROID LUKS MOUNTER - Professional Storage Management                 #
#                                                                              #
#   üë§ Author: Rex Ackermann                                                   #
#   üåê GitHub: https://github.com/rexackermann                                 #
#   üè∑Ô∏è Version: v1.4.2-ULTIMATE                                               #
#                                                                              #
#   üõ†Ô∏è  Requirements: Root (Magisk/KSU), Termux, Cryptsetup, Bindfs, Blkid     #
#   ‚öñÔ∏è  License: MIT                                                           #
#                                                                              #
################################################################################

# --- üì¶ Configuration ---
# üìÅ Directory where your LUKS keyfiles will be stored securely.
KEY_DIR="/storage/emulated/0/Documents/luks_keys"
# üìÇ Default parent directory for all your mount points in the Android storage.
DEFAULT_BASE_STORAGE="/storage/emulated/0/ext"

# --- ‚ú® Visual Polish (ANSI Colors) ---
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m' # No Color

# --- üåç Environment Discovery & Setup ---
# This section aligns the environment with Termux's internal standards,
# ensuring that even when running as root from system shells, we find
# the correct binaries, libraries, and users.

TERMUX_PREFIX="/data/data/com.termux/files/usr"
TERMUX_HOME="/data/data/com.termux/files/home"
TERMUX_TMPDIR="$TERMUX_PREFIX/tmp"
SYSTEM_PATHS="/sbin:/system/sbin:/system/bin:/system/xbin:/data/local/bin"

if [ -d "$TERMUX_PREFIX" ]; then
    # üîç Deterministic User Discovery: Lookup based on file ownership
    TERMUX_UID=$(stat -c %u "$TERMUX_PREFIX")
    TERMUX_USER="u0_a$(($TERMUX_UID - 10000))"

    # üìö Export Termux paths and prioritize them
    CLEAN_PATH=$(echo "$PATH" | sed -E "s|$TERMUX_PREFIX/bin:||g; s|:$TERMUX_PREFIX/bin||g")
    export PATH="$TERMUX_PREFIX/bin:$TERMUX_PREFIX/bin/applets:$SYSTEM_PATHS:$CLEAN_PATH"
    export LD_LIBRARY_PATH="$TERMUX_PREFIX/lib${LD_LIBRARY_PATH:+:$LD_LIBRARY_PATH}"
    
    # ÔøΩÔ∏è Fix shebangs and app execution compatibility
    if [ -f "$TERMUX_PREFIX/lib/libtermux-exec.so" ]; then
        export LD_PRELOAD="$TERMUX_PREFIX/lib/libtermux-exec.so"
    fi

    # üîß Standard Termux Environment Variables
    export PREFIX="$TERMUX_PREFIX"
    export HOME="$TERMUX_HOME"
    export TMPDIR="$TERMUX_TMPDIR"
    export USER="$TERMUX_USER"
    export LOGNAME="$TERMUX_USER"
    [ -z "$TERM" ] && export TERM="xterm-256color"
    [ -z "$COLORTERM" ] && export COLORTERM="truecolor"
    [ -z "$LANG" ] && export LANG="en_US.UTF-8"
else
    # üì± Fallback for non-Termux/Minimal environments
    export PATH="$PATH:$SYSTEM_PATHS"
fi

export PATH
export LD_LIBRARY_PATH

# --- üõ†Ô∏è Tool Discovery & Absolute Path Enforcement ---
# We explicitly locate the best versions of our required binaries.
# If a tool exists in Termux, we take its absolute path to avoid Toybox conflicts.

find_tool() {
    local tool=$1
    local path
    
    # 1. Primary: Termux Binaries
    if [ -x "$TERMUX_PREFIX/bin/$tool" ]; then
        path="$TERMUX_PREFIX/bin/$tool"
    # 2. Secondary: Termux Applets
    elif [ -x "$TERMUX_PREFIX/bin/applets/$tool" ]; then
        path="$TERMUX_PREFIX/bin/applets/$tool"
    # 3. Tertiary: System Fallback
    else
        path=$(command -v "$tool" 2>/dev/null)
        # Ensure it's an absolute path
        case "$path" in
            /*) ;;
            *) path="" ;;
        esac
    fi
    
    if [ -z "$path" ]; then
        return 1
    fi
    echo "$path"
}

# Identify and Lock-in tool paths at startup for deterministic execution.
log "Discovering core utilities..."
NSENTER_BIN=$(find_tool nsenter) || warn "nsenter not found!"
BINDFS_BIN=$(find_tool bindfs) || warn "bindfs not found!"
CRYPTSETUP_BIN=$(find_tool cryptsetup) || warn "cryptsetup not found!"
MOUNT_BIN=$(find_tool mount) || warn "mount not found!"
UMOUNT_BIN=$(find_tool umount) || warn "umount not found!"
BLKID_BIN=$(find_tool blkid) || warn "blkid not found!"

# Utility tools
MKDIR_BIN=$(find_tool mkdir)
CHMOD_BIN=$(find_tool chmod)
CHOWN_BIN=$(find_tool chown)
LN_BIN=$(find_tool ln)
NTFS3G_BIN=$(find_tool ntfs-3g)
CAT_BIN=$(find_tool cat)
RM_BIN=$(find_tool rm)

log "Binary Registry:"
echo "  [nsenter]     -> ${NSENTER_BIN:-MISSING!}"
echo "  [bindfs]      -> ${BINDFS_BIN:-MISSING!}"
echo "  [cryptsetup]  -> ${CRYPTSETUP_BIN:-MISSING!}"
echo "  [mount]       -> ${MOUNT_BIN:-MISSING!}"
echo "  [umount]      -> ${UMOUNT_BIN:-MISSING!}"
echo "  [blkid]       -> ${BLKID_BIN:-MISSING!}"

# üõ°Ô∏è Safety: Fail early if critical tools are missing.
if [ -z "$NSENTER_BIN" ] || [ -z "$BINDFS_BIN" ] || [ -z "$CRYPTSETUP_BIN" ]; then
    error "One or more critical tools are missing. Please install them in Termux."
    exit 1
fi

# --- üõ†Ô∏è Helper Functions ---

# üìù Standardized logging with a splash of color.
log() {
    echo -e "${CYAN}${BOLD}[*]${NC} $1"
}

# üèÉ Execute commands and show the user exactly what is happening in the background.
run_cmd() {
    local cmd="$1"
    
    # üîç Intelligence: If we are calling 'nsenter', we swap the generic command
    # for the discovered absolute binary path (Termux version).
    if [ "$cmd" = "nsenter" ] && [ -n "$NSENTER_BIN" ]; then
        shift
        echo -e "  ${PURPLE}‚ûú${NC} ${BLUE}Running:${NC} ${BOLD}$NSENTER_BIN $@${NC}"
        "$NSENTER_BIN" "$@"
    else
        echo -e "  ${PURPLE}‚ûú${NC} ${BLUE}Running:${NC} ${BOLD}$@${NC}"
        "$@"
    fi
}

# üö® Error reporting to STDERR with high visibility.
error() {
    echo -e "${RED}${BOLD}[!] Error:${NC} $1" >&2
}

# ‚ö†Ô∏è Warning reporting for non-critical but important status updates.
warn() {
    echo -e "${YELLOW}${BOLD}[!] Warning:${NC} $1" >&2
}

# --- ‚öôÔ∏è Core Functions ---

# üîç Dependency Check: Ensure the required tools are installed and accessible.
check_tools() {
    # üõ†Ô∏è These binaries are the backbone of our mounting logic.
    for tool in cryptsetup nsenter mount bindfs blkid; do
        if ! command -v "$tool" >/dev/null 2>&1; then
            error "Required tool '$tool' not found in PATH."
            error "üí° Tip: Install them in Termux via: pkg install cryptsetup bindfs"
            exit 1
        fi
    done

    # üìÇ Persistence: Ensure the configuration and key directory exists.
    if [ ! -d "$KEY_DIR" ]; then
        log "Creating key directory: $KEY_DIR"
        "$MKDIR_BIN" -p "$KEY_DIR"
        # üîë Set restricted permissions (Owner only) for security.
        "$CHMOD_BIN" 700 "$KEY_DIR"
    fi
}

# üìñ Manual: Display a beautiful and informative help menu.
usage() {
    echo -e "${GREEN}${BOLD}Android LUKS Mounter${NC} ‚ú®"
    echo -e "${BOLD}Usage:${NC} $0 [options] <device> [label]"
    echo ""
    echo -e "${YELLOW}${BOLD}Options:${NC}"
    echo "  -u, --unmount <label>   üîí Unmount a drive using its label."
    echo "  --install-service       ü§ñ Install as a background service (Magisk/KSU)."
    echo "  --link-bin [path]       üîó Create 'mounter' alias in /system/bin (default)."
    echo "  --scan                  üì° Scan connected drives & update config (No mount)."
    echo "  --auto-update-config    üîÑ Sync config AND mount everything connected."
    echo "  --all                   ‚ö° Auto-mount all recognized devices."
    echo "  -h, --help              ‚ùì Show this help message."
    echo ""
    echo -e "${YELLOW}${BOLD}Examples:${NC}"
    echo "  $0 /dev/block/sda1 MyDrive   # üìÇ Mount sda1 as MyDrive"
    echo "  $0 -u MyDrive                # üì§ Unmount MyDrive"
    echo "  $0 --all                     # ‚ö° Quick mount everything"
    echo "  $0 --link-bin                # üîó Run 'mounter' from anywhere!"
    exit 0
}

# ‚öôÔ∏è Config Loader: Syncs the script with your saved preferences.
load_config() {
    local config_file="$KEY_DIR/config"
    # üå± Auto-generate a default template if none exists.
    if [ ! -f "$config_file" ]; then
        log "Generating default config at $config_file"
        "$CAT_BIN" > "$config_file" <<EOF
# üöÄ Android Mounter Configuration - Rex Ackermann

# üìÇ Path to secure LUKS keyfiles
# KEY_DIR="$KEY_DIR"

# üìÅ Parent directory for mount points
# BASE_STORAGE_PATH="$DEFAULT_BASE_STORAGE"

# ‚è±Ô∏è Refresh interval for auto-mount service (seconds)
# POLL_INTERVAL=5

# --- üíæ Saved Labels (Auto-generated by --scan or mount) ---
EOF
    fi
    
    # üîå Read the config into the current shell process.
    source "$config_file"
    # üî• Use config value if provided, else fall back to script default.
    BASE_STORAGE="${BASE_STORAGE_PATH:-$DEFAULT_BASE_STORAGE}"
}

# üîó Global Access: Creates a symlink for easy 'mounter' execution.
link_bin() {
    local link_path="${1:-/system/bin/mounter}"
    local script_path=$(readlink -f "$0")

    log "Attempting to link $script_path to $link_path..."
    
    # üîì Try remounting /system as RW for linking.
    if [[ "$link_path" == /system/* ]]; then
         run_cmd nsenter -t 1 -m -- mount -o remount,rw /system 2>/dev/null
    fi

    if run_cmd "$LN_BIN" -sf "$script_path" "$link_path"; then
        run_cmd "$CHMOD_BIN" +x "$link_path"
        log "Success! You can now run '${BOLD}$link_path${NC}' from anywhere."
    else
        error "Failed to create symlink. Try: $0 --link-bin /data/local/bin/mounter"
    fi
}

# ü§ñ Service Daemon: Creates a Magisk/KSU boot script for auto-mounting.
install_service() {
    local service_dir="/data/adb/service.d"
    local service_file="$service_dir/mount_block_device.sh"
    local script_path=$(readlink -f "$0")

    if [ ! -d "$service_dir" ]; then
        error "Service directory $service_dir not found. Are you using Magisk/KernelSU?"
        return 1
    fi

    log "Installing service to $service_file..."
    
    "$CAT_BIN" > "$service_file" <<EOF
#!/system/bin/sh
# üõ°Ô∏è Auto-generated by Android Mounter - Rex Ackermann
sleep 15
INTERVAL=\${POLL_INTERVAL:-5}
while true; do
    # üîÑ Periodically check and mount all devices.
    $script_path --all >> /data/local/tmp/mounter.log 2>&1
    sleep \$INTERVAL
done
EOF

    run_cmd "$CHMOD_BIN" +x "$service_file"
    log "Service installed! ‚ú® Reboot to start auto-mounting."
}

# --- üìÅ Mounting Logic Functions ---

# üßπ Cleanup: Audit all mounts and remove orphans from missing devices.
cleanup_stale_mounts() {
    # 1Ô∏è‚É£ Check for active LUKS mappers with no backing block device.
    for mapper in /dev/mapper/luks_*; do
        [ ! -e "$mapper" ] && continue
        local mapper_name=$(basename "$mapper")
        local status=$("$CRYPTSETUP_BIN" status "$mapper_name" 2>/dev/null)
        local device=$(echo "$status" | grep "device:" | awk '{print $2}')
        
        if [ -n "$device" ] && [ ! -b "$device" ]; then
            log "Detected stale LUKS: $mapper_name (Device $device missing)"
            local mnt_point=$(grep "$mapper" /proc/mounts | awk '{print $2}' | head -n 1)
            [ -n "$mnt_point" ] && unmount_device "$(basename "$mnt_point")" || run_cmd "$CRYPTSETUP_BIN" close "$mapper_name"
        fi
    done

    # 2Ô∏è‚É£ Scan all mount points for block devices that no longer exist.
    cat /proc/mounts | grep -E "/mnt/media_rw/|/storage/emulated/0/" | while read -r line; do
        local dev=$(echo "$line" | awk '{print $1}')
        local mnt=$(echo "$line" | awk '{print $2}')
        if [[ "$dev" == /dev/block/* ]] || [[ "$dev" == /dev/mapper/* ]]; then
            [ ! -e "$dev" ] && log "Cleaning stale mount: $mnt" && unmount_device "$(basename "$mnt")"
        fi
    done
}

# üîç Finder: Check if a device is already unlocked in /dev/mapper.
find_existing_mapper() {
    local dev=$1
    for mapper in /dev/mapper/luks_*; do
        [ ! -e "$mapper" ] && continue
        "$CRYPTSETUP_BIN" status "$(basename "$mapper")" 2>/dev/null | grep -q "device:  $dev" && echo "$(basename "$mapper")" && return 0
    done
    return 1
}

# üì§ Unmounter: Safely detach storage and close encryption.
unmount_device() {
    local label=$1
    [ -z "$label" ] && error "Label is required." && return 1
    log "Unmounting $label..."

    # üîì 1. Kill all bindfs views for this label.
    grep "/storage/emulated/0/.*$label " /proc/mounts | awk '{print $2}' | while read -r sp; do
        run_cmd nsenter -t 1 -m -- umount "$sp" && log "Detached user view: $sp"
    done

    # üìÅ 2. Unmount the physical hardware point.
    local mnt_point="/mnt/media_rw/$label"
    mount | grep -q " $mnt_point " && run_cmd nsenter -t 1 -m -- umount "$mnt_point"

    # üîí 3. Seal the LUKS vault.
    for dev in /dev/mapper/luks_${label}_*; do
        [ -e "$dev" ] && log "Closing LUKS: $(basename "$dev")" && run_cmd "$CRYPTSETUP_BIN" close "$(basename "$dev")"
    done
}

# üìÇ Main Mounter: The core engine for unlocking and mounting.
mount_device() {
    local device=$1
    local label=$2
    
    # üõ°Ô∏è Safety: Skip internal storage and other non-target blocks.
    [ ! -b "$device" ] && return 1
    case "$device" in *mmcblk0*|*dm-*|*loop*) [ "$AUTO_MODE" != "1" ] && error "Safety: $device is internal." ; return 1 ;; esac

    # üè∑Ô∏è Auto-label if none provided.
    [ -z "$label" ] && label=$(basename "$device")
    local mnt_point="/mnt/media_rw/$label"

    # üö¶ Avoid double-mounting if already active.
    mount | grep -q " $mnt_point " && warn "$mnt_point already mounted." && return 0
    grep -q "^$device " /proc/mounts && warn "$device already mounted." && return 0

    log "Targeting: ${BOLD}$device${NC} ($label)"

    # üîì LUKS Detection & Decoding.
    local existing_mapper=$(find_existing_mapper "$device")
    local unlocked=0
    local mapper_name=""
    local uuid
    local IS_LUKS=1

    if [ -n "$existing_mapper" ]; then
        log "$device is already open as $existing_mapper"
        mapper_name="$existing_mapper" ; unlocked=1
        grep -q "^/dev/mapper/$mapper_name " /proc/mounts && warn "$mapper_name already mounted." && return 0
    fi

    if ! uuid=$("$CRYPTSETUP_BIN" luksUUID "$device" 2>/dev/null); then
         IS_LUKS=0 ; uuid=$("$BLKID_BIN" -o value -s UUID "$device" 2>/dev/null)
         [ -z "$uuid" ] && uuid=$(echo "$device" | tr '/' '_')
         log "Plain device detected. UUID: $uuid"
    else
         log "LUKS device detected. UUID: $uuid"
    fi

    # üíæ Config Lookup: Restore saved label and path.
    local safe_uuid=$(echo "$uuid" | tr '-' '_')
    eval "saved_label=\${MAPPING_${safe_uuid}}"
    eval "saved_storage_path=\${STORAGE_PATH_${safe_uuid}}"
    [ -n "$saved_label" ] && ( [ -z "$label" ] || [ "$AUTO_MODE" = "1" ] ) && label="$saved_label"
    local storage_point="${saved_storage_path:-$BASE_STORAGE/$label}"

    # üß† Mapper Identification.
    if [ $IS_LUKS -eq 1 ]; then
        if [ $unlocked -eq 0 ]; then
            local rand_suffix=$(head -n 1 /dev/urandom | tr -dc 'a-f0-9' | head -c 6)
            mapper_name="luks_${label}_${rand_suffix}"
        fi
        TARGET_DEV="/dev/mapper/$mapper_name"
    else
        unlocked=1 ; TARGET_DEV="$device"
    fi

    # üîë Auto-Unlock Sequence.
    local keyfile="$KEY_DIR/$uuid.key"
    if [ $unlocked -eq 0 ] && [ -f "$keyfile" ]; then
        run_cmd "$CRYPTSETUP_BIN" open "$device" "$mapper_name" --key-file "$keyfile" && unlocked=1
    fi

    # üïµÔ∏è Brute-force: Try all keys in the key directory.
    if [ $unlocked -eq 0 ]; then
        for k in "$KEY_DIR"/*; do
            [ ! -f "$k" ] || [ "$k" = "$keyfile" ] || [ "$(basename "$k")" = "config" ] && continue
            run_cmd "$CRYPTSETUP_BIN" open "$device" "$mapper_name" --key-file "$k" && unlocked=1 && break
        done
    fi

    # ‚å®Ô∏è Interactive Unlock: Password fallback.
    if [ $unlocked -eq 0 ]; then
        log "Manual unlock needed for $device:"
        echo " 1) Password (default) | 2) Select Keyfile | s) Skip"
        read -r unlock_opt
        case "$unlock_opt" in
            2) printf "Keyfile path: " ; read -r mk ; [ -f "$mk" ] && run_cmd "$CRYPTSETUP_BIN" open "$device" "$mapper_name" --key-file "$mk" && unlocked=1 ;;
            s|S) return 1 ;;
            *) log "Password for $device:" ; stty -echo ; read -r PASS ; stty echo ; echo "" 
               echo -n "$PASS" | run_cmd "$CRYPTSETUP_BIN" open "$device" "$mapper_name" && unlocked=1 || { error "Failed." ; unset PASS ; return 1 ; } 
               ;;
        esac
        # üîë Offer to save this as a keyfile for next time.
        if [ $unlocked -eq 1 ]; then
            log "Successfully unlocked! ‚ú®"
            echo "Save new keyfile for auto-unlock? [y/N]" ; read -r sk
            if [ "$sk" = "y" ]; then
                dd if=/dev/urandom of="$keyfile" bs=512 count=1 >/dev/null 2>&1 ; chmod 600 "$keyfile"
                [ -n "$PASS" ] && echo -n "$PASS" | run_cmd "$CRYPTSETUP_BIN" luksAddKey "$device" "$keyfile" || run_cmd "$CRYPTSETUP_BIN" luksAddKey "$device" "$keyfile"
            fi
        fi ; unset PASS
    fi

    # üìÅ Mounting Process.
    [ ! -d "$mnt_point" ] && run_cmd "$MKDIR_BIN" -p "$mnt_point" && run_cmd "$CHMOD_BIN" 0775 "$mnt_point" && run_cmd "$CHOWN_BIN" root:1023 "$mnt_point"
    
    MOUNTED=0
    # 0. Pass environment to nsenter'ed commands
    local NS_ENV="env PATH=$PATH LD_LIBRARY_PATH=$LD_LIBRARY_PATH LD_PRELOAD=$LD_PRELOAD"
    
    # 1. System Auto-detect.
    run_cmd nsenter -t 1 -m -- $NS_ENV "$MOUNT_BIN" "$TARGET_DEV" "$mnt_point" && MOUNTED=1
    # 2. NTFS Fallback.
    [ $MOUNTED -eq 0 ] && [ -n "$NTFS3G_BIN" ] && run_cmd nsenter -t 1 -m -- $NS_ENV "$NTFS3G_BIN" "$TARGET_DEV" "$mnt_point" && MOUNTED=1
    # 3. Blkid Force.
    [ $MOUNTED -eq 0 ] && FS=$("$BLKID_BIN" -o value -s TYPE "$TARGET_DEV") && [ -n "$FS" ] && run_cmd nsenter -t 1 -m -- $NS_ENV "$MOUNT_BIN" -t "$FS" "$TARGET_DEV" "$mnt_point" && MOUNTED=1
    # 4. Kernel Brute-force.
    [ $MOUNTED -eq 0 ] && for fs in $(cat /proc/filesystems | grep -v "nodev" | awk '{print $2}'); do
        run_cmd nsenter -t 1 -m -- $NS_ENV "$MOUNT_BIN" -t "$fs" "$TARGET_DEV" "$mnt_point" >/dev/null 2>&1 && MOUNTED=1 && break
    done

    [ $MOUNTED -eq 0 ] && error "Mount failed." && [ -n "$mapper_name" ] && run_cmd "$CRYPTSETUP_BIN" close "$mapper_name" && return 1

    # üíæ Remember this device label for the future.
    save_config_label "$uuid" "$label" "$device"

    # üîó User View: Create a bindfs point for app accessibility.
    [ ! -d "$storage_point" ] && run_cmd "$MKDIR_BIN" -p "$storage_point" && run_cmd "$CHMOD_BIN" 0775 "$storage_point" && run_cmd "$CHOWN_BIN" root:1023 "$storage_point"
    if run_cmd nsenter -t 1 -m -- $NS_ENV "$BINDFS_BIN" --map=root/1023:@root/@1023 --create-with-perms=0775 "$mnt_point" "$storage_point"; then
        log "Success! üéä Your drive is now at: ${BOLD}$storage_point${NC}"
    else
        warn "Bindfs failed. Detaching..." ; run_cmd nsenter -t 1 -m -- "$UMOUNT_BIN" "$mnt_point"
        [ -n "$mapper_name" ] && run_cmd "$CRYPTSETUP_BIN" close "$mapper_name" ; return 1
    fi
}

# üì° Scanner: Discover and register all connected partitions.
scan_all_devices() {
    log "Scanning all partitions... üì°"
    local added=0
    for dev in $(ls /dev/block/sd* /dev/block/mmcblk1* 2>/dev/null); do
        case "$(basename "$dev")" in sd[a-z]|mmcblk1) ls "${dev}"[0-9]* >/dev/null 2>&1 || ls "${dev}"p[0-9]* >/dev/null 2>&1 && continue ;; esac
        local uuid
        if ! uuid=$("$CRYPTSETUP_BIN" luksUUID "$dev" 2>/dev/null); then uuid=$("$BLKID_BIN" -o value -s UUID "$dev" 2>/dev/null) ; [ -z "$uuid" ] && uuid=$(echo "$dev" | tr '/' '_') ; fi
        local label=$("$BLKID_BIN" -o value -s LABEL "$dev" 2>/dev/null) ; [ -z "$label" ] && label=$(basename "$dev")
        save_config_label "$uuid" "$label" "$dev" && added=$((added + 1))
    done
    log "Scan complete. Added $added new device entries! ‚ú®"
}

# üíæ Config Persistence: Save device-to-label mappings safely.
save_config_label() {
    local uuid="$1" ; local label="$2" ; local dev_path="$3" ; local config_file="$KEY_DIR/config"
    [ ! -f "$config_file" ] && return 1
    local safe_uuid=$(echo "$uuid" | tr '-' '_')
    grep -q "MAPPING_${safe_uuid}=" "$config_file" && return 1
    log "Mapping $label to $uuid... üíæ"
    local type="OTG" ; [[ "$dev_path" == *mmcblk* ]] && type="MMC"
    echo -e "\n# --- $type Device: $uuid ---" >> "$config_file"
    echo "MAPPING_${safe_uuid}=\"$label\"" >> "$config_file"
    echo "STORAGE_PATH_${safe_uuid}=\"$BASE_STORAGE/$label\"" >> "$config_file"
    return 0
}

# --- üöÄ Main Execution Block ---
SESSION_ID=$(date +%s)_$((RANDOM % 1000))
log "Starting Android LUKS Mounter v1.4.3-ULTIMATE ‚ú®"
log "Session ID: $SESSION_ID"
log "Executing from: $(readlink -f "$0")"

# 1Ô∏è‚É£ Load user settings first.
[ ! -d "$KEY_DIR" ] && "$MKDIR_BIN" -p "$KEY_DIR"
load_config
check_tools

MODE="mount" ; AUTO_MODE="0" ; DEVICE="" ; LABEL=""

# 2Ô∏è‚É£ Parse command line arguments.
while [ $# -gt 0 ]; do
    case "$1" in
        -h|--help) usage ;;
        --install-service) MODE="install_service" ; shift ;;
        --link-bin) MODE="link_bin" ; shift ; [ -n "$1" ] && [[ "$1" != -* ]] && LINK_PATH="$1" && shift ;;
        -u|--unmount) MODE="unmount" ; shift ;;
        --all) MODE="mount" ; AUTO_MODE="1" ; shift ;;
        --scan) MODE="scan" ; shift ;;
        --auto-update-config) MODE="auto_update" ; AUTO_MODE="1" ; shift ;;
        *) [ -z "$DEVICE" ] && [ "$MODE" != "unmount" ] && DEVICE="$1" || LABEL="$1" ; shift ;;
    esac
done

# 3Ô∏è‚É£ Dispatch to the appropriate mode.
case "$MODE" in
    install_service) install_service ; exit 0 ;;
    link_bin) link_bin "$LINK_PATH" ; exit 0 ;;
    unmount) [ -z "$LABEL" ] && [ -n "$DEVICE" ] && LABEL="$DEVICE" ; unmount_device "$LABEL" ; exit 0 ;;
    scan) scan_all_devices ; exit 0 ;;
    auto_update) log "Auto-updating config... üîÑ" ; scan_all_devices ; ;;
esac

# 4Ô∏è‚É£ Handle Mounting (Auto or Manual).
if [ "$AUTO_MODE" = "1" ]; then
    log "Engaging auto-mount mode... ‚ö°" ; cleanup_stale_mounts
    for dev in $(ls /dev/block/sd* /dev/block/mmcblk1* 2>/dev/null); do
        case "$(basename "$dev")" in sd[a-z]|mmcblk1) ls "${dev}"[0-9]* >/dev/null 2>&1 || ls "${dev}"p[0-9]* >/dev/null 2>&1 && continue ;; esac
        mount_device "$dev" ""
    done
else
    # Manual Mount: Requires at least a device path.
    [ -z "$DEVICE" ] && usage
    mount_device "$DEVICE" "$LABEL"
fi

################################################################################
# üèÅ Created with ‚ù§Ô∏è by Rex Ackermann                                          #
################################################################################
