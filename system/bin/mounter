#!/system/bin/sh

################################################################################
#                                                                              #
#   üöÄ ANDROID LUKS MOUNTER - Professional Storage Management                 #
#                                                                              #
#   üë§ Author: Rex Ackermann                                                   #
#   üåê GitHub: https://github.com/rexackermann                                 #
#   üè∑Ô∏è Version: v1.5.31-BINDFS-FIX                                             #
#                                                                              #
#   üõ†Ô∏è  Requirements: Root (Magisk/KSU), Termux, Cryptsetup, Bindfs, Blkid     #
#   ‚öñÔ∏è  License: MIT                                                           #
#                                                                              #
################################################################################

# --- üì¶ Configuration ---
# üìÅ KEY_DIR: Storage location for LUKS keyfiles.
#    Security Note: This directory is chmod 700 (Owner Only) to prevents apps from stealing keys.
KEY_DIR="/storage/emulated/0/Documents/luks_keys"

# üìÇ DEFAULT_BASE_STORAGE: The Android-accessible folder where drives appear.
#    This path is technically a Bindfs view or a Bind mount of the real mount point.
DEFAULT_BASE_STORAGE="/storage/emulated/0/ext"

# --- ‚ú® Visual Polish (ANSI Colors) ---
# We use printf to generate real escape characters to avoid shell literal issues (e.g. \033 vs \e).
# These colors define the visual identity of the script in the terminal.
RED=$(printf '\033[0;31m')
GREEN=$(printf '\033[0;32m')
YELLOW=$(printf '\033[1;33m')
BLUE=$(printf '\033[0;34m')
PURPLE=$(printf '\033[0;35m')
CYAN=$(printf '\033[0;36m')
BOLD=$(printf '\033[1m')
NC=$(printf '\033[0m') # No Color (Reset)

# --- üåç Environment Discovery & Setup ---
# Significance:
# Android's root shell environment differs vastly from the Termux environment.
# Libraries, specific binaries, and paths are often missing or point to Toybox applets.
# This section aligns the runtime environment with Termux's internal standards.

TERMUX_PREFIX="/data/data/com.termux/files/usr"
TERMUX_HOME="/data/data/com.termux/files/home"
TERMUX_TMPDIR="$TERMUX_PREFIX/tmp"
SYSTEM_PATHS="/sbin:/system/sbin:/system/bin:/system/xbin:/data/local/bin"
FAILURE_TRACKING_DIR="/data/local/tmp/mounter_failures"

if [ -d "$TERMUX_PREFIX" ]; then
    # üîç Deterministic User Discovery:
    # Instead of guessing the user ID (usually u0_aXXX), we derive it from the file ownership
    # of the Termux directory itself. This guarantees we use the correct UID for permissions.
    TERMUX_UID=$(stat -c %u "$TERMUX_PREFIX")
    TERMUX_USER="u0_a$(($TERMUX_UID - 10000))"

    # üìö Path Injection:
    # We prepend Termux binary paths to PATH to ensure we use valid GNU tools (like grep, ls)
    # instead of limited Android Toybox versions.
    CLEAN_PATH=$(echo "$PATH" | sed -E "s|$TERMUX_PREFIX/bin:||g; s|:$TERMUX_PREFIX/bin||g")
    export PATH="$TERMUX_PREFIX/bin:$TERMUX_PREFIX/bin/applets:$SYSTEM_PATHS:$CLEAN_PATH"
    
    # üìö Library Linking:
    # Export LD_LIBRARY_PATH so binaries like 'cryptsetup' can find 'libcryptsetup.so'.
    export LD_LIBRARY_PATH="$TERMUX_PREFIX/lib${LD_LIBRARY_PATH:+:$LD_LIBRARY_PATH}"
    
    # Ô∏è Execution Fix (Shebangs):
    # Some Termux binaries rely on libtermux-exec.so to intercept exec calls and fix 
    # hardcoded shebang paths (e.g. /usr/bin/env).
    if [ -f "$TERMUX_PREFIX/lib/libtermux-exec.so" ]; then
        export LD_PRELOAD="$TERMUX_PREFIX/lib/libtermux-exec.so"
    fi

    # üîß Standard Termux Environment Variables
    export PREFIX="$TERMUX_PREFIX"
    export HOME="$TERMUX_HOME"
    export TMPDIR="$TERMUX_TMPDIR"
    export USER="$TERMUX_USER"
    export LOGNAME="$TERMUX_USER"
    [ -z "$TERM" ] && export TERM="xterm-256color"
    [ -z "$COLORTERM" ] && export COLORTERM="truecolor"
    [ -z "$LANG" ] && export LANG="en_US.UTF-8"
else
    # üì± Fallback: If Termux isn't found, we run with standard system paths.
    export PATH="$PATH:$SYSTEM_PATHS"
fi

export PATH
export LD_LIBRARY_PATH

# --- üõ†Ô∏è Tool Discovery & Absolute Path Enforcement ---
# We explicitly locate the best versions of our required binaries.
# Using absolute paths prevents "command not found" errors in cron/boot scripts
# and avoids accidental execution of system binaries with same names (e.g. Toybox mount).

find_tool() {
    local tool=$1
    local path
    
    # 1. Primary: Termux Binaries (Preferred)
    if [ -x "$TERMUX_PREFIX/bin/$tool" ]; then
        path="$TERMUX_PREFIX/bin/$tool"
    # 2. Secondary: Termux Applets (Busybox symlinks)
    elif [ -x "$TERMUX_PREFIX/bin/applets/$tool" ]; then
        path="$TERMUX_PREFIX/bin/applets/$tool"
    # 3. Tertiary: System Fallback (Toybox/System toolbox)
    else
        path=$(command -v "$tool" 2>/dev/null)
        # Ensure it's an absolute path for safety
        case "$path" in
            /*) ;;
            *) path="" ;;
        esac
    fi
    
    if [ -z "$path" ]; then
        return 1
    fi
    echo "$path"
}

# Identify and Lock-in tool paths at startup for deterministic execution.
log "Discovering core utilities..."
NSENTER_BIN=$(find_tool nsenter) || warn "nsenter not found!"
BINDFS_BIN=$(find_tool bindfs) || warn "bindfs not found!"
CRYPTSETUP_BIN=$(find_tool cryptsetup) || warn "cryptsetup not found!"
MOUNT_BIN=$(find_tool mount) || warn "mount not found!"
UMOUNT_BIN=$(find_tool umount) || warn "umount not found!"
BLKID_BIN=$(find_tool blkid) || warn "blkid not found!"

# Utility tools
MKDIR_BIN=$(find_tool mkdir)
CHMOD_BIN=$(find_tool chmod)
CHOWN_BIN=$(find_tool chown)
LN_BIN=$(find_tool ln)
NTFS3G_BIN="$TERMUX_PREFIX/bin/ntfs-3g"
NTFSFIX_BIN="$TERMUX_PREFIX/bin/ntfsfix"
CAT_BIN=$(find_tool cat)
RM_BIN=$(find_tool rm)

log "Binary Registry:"
echo "  [nsenter]     -> ${NSENTER_BIN:-MISSING!}"
echo "  [bindfs]      -> ${BINDFS_BIN:-MISSING!}"
echo "  [cryptsetup]  -> ${CRYPTSETUP_BIN:-MISSING!}"
echo "  [mount]       -> ${MOUNT_BIN:-MISSING!}"
echo "  [umount]      -> ${UMOUNT_BIN:-MISSING!}"
echo "  [blkid]       -> ${BLKID_BIN:-MISSING!}"

# üõ°Ô∏è Safety: Fail early if critical tools are missing.
if [ -z "$NSENTER_BIN" ] || [ -z "$BINDFS_BIN" ] || [ -z "$CRYPTSETUP_BIN" ]; then
    error "One or more critical tools are missing. Please install them in Termux."
    exit 1
fi

# --- üõ†Ô∏è Helper Functions ---

# üìù Log: Standardized logging with a splash of color and timestamp.
log() {
    echo -e "${CYAN}${BOLD}[$(date "+%Y-%m-%d %H:%M:%S")] [*]${NC} $1"
}

# üèÉ Run Cmd: Execute commands and show the user exactly what is happening.
run_cmd() {
    local cmd="$1"
    
    # üîç Intelligence: If we are calling 'nsenter', we swap the generic command
    # for the discovered absolute binary path (Termux version).
    if [ "$cmd" = "nsenter" ] && [ -n "$NSENTER_BIN" ]; then
        shift
        echo -e "  ${PURPLE}‚ûú${NC} ${BLUE}Running:${NC} ${BOLD}$NSENTER_BIN $@${NC}"
        "$NSENTER_BIN" "$@"
    else
        echo -e "  ${PURPLE}‚ûú${NC} ${BLUE}Running:${NC} ${BOLD}$@${NC}"
        "$@"
    fi
}

# üö® Error: Reporting to STDERR with high visibility.
error() {
    echo -e "${RED}${BOLD}[$(date "+%Y-%m-%d %H:%M:%S")] [!] Error:${NC} $1" >&2
}

# ‚ö†Ô∏è Warn: Reporting for non-critical but important status updates.
warn() {
    echo -e "${YELLOW}${BOLD}[$(date "+%Y-%m-%d %H:%M:%S")] [!] Warning:${NC} $1" >&2
}

# üîî Notification: Send Android Notification (ADB Style)
# Utilizes the 'shell' user (UID 2000) to inject notifications into the system UI.
send_notification() {
    local title="$1"
    local message="$2"
    # Optional unique tag for stacking (default if not provided)
    local tag="${3:-AndroidMounter}"
    
    if command -v cmd >/dev/null 2>&1; then
        run_cmd su -lp 2000 -c "cmd notification post -S bigtext -t '$title' '$tag' '$message'" >/dev/null 2>&1
    else
        warn "cmd notification not available."
    fi
}

# --- ‚öôÔ∏è Core Functions ---

# üîç Check Tools: Verify required tools are installed and accessible.
check_tools() {
    # üõ†Ô∏è These binaries are the backbone of our mounting logic.
    for tool in cryptsetup nsenter mount bindfs blkid; do
        if ! command -v "$tool" >/dev/null 2>&1; then
            error "Required tool '$tool' not found in PATH."
            error "üí° Tip: Install them in Termux via: pkg install cryptsetup bindfs"
            exit 1
        fi
    done

    # üìÇ Persistence: Ensure the configuration and key directory exists.
    if [ ! -d "$KEY_DIR" ]; then
        log "Creating key directory: $KEY_DIR"
        "$MKDIR_BIN" -p "$KEY_DIR"
        # üîë Set restricted permissions (Owner only) for security.
        "$CHMOD_BIN" 700 "$KEY_DIR"
    fi
}

# üìñ Usage: Display a beautiful and informative help menu.
usage() {
    echo -e "${GREEN}${BOLD}Android LUKS Mounter${NC} ‚ú®"
    echo -e "${BOLD}Usage:${NC} $0 [options] <device> [label]"
    echo ""
    echo -e "${YELLOW}${BOLD}Options:${NC}"
    echo "  -u, --unmount <label>   üîí Unmount a drive using its label."
    echo "  -s, --status            üìä Show a status dashboard of all mounts."
    echo "  --install-service       ü§ñ Install as a background service (Magisk/KSU)."
    echo "  --link-bin [path]       üîó Create 'mounter' alias in /system/bin (default)."
    echo "  --scan                  üì° Scan connected drives & update config (No mount)."
    echo "  --auto-update-config    üîÑ Sync config AND mount everything connected."
    echo "  --all                   ‚ö° Auto-mount all recognized devices."
    echo "  -h, --help              ‚ùì Show this help message."
    echo ""
    exit 0
}

# ‚öôÔ∏è Config Loader: Syncs the script with your saved preferences.
load_config() {
    local config_file="$KEY_DIR/config"
    # üå± Auto-generate a default template if none exists.
    if [ ! -f "$config_file" ]; then
        log "Generating default config at $config_file"
        "$CAT_BIN" > "$config_file" <<EOF
# üöÄ Android Mounter Configuration - Rex Ackermann

# üìÇ Path to secure LUKS keyfiles
# KEY_DIR="$KEY_DIR"

# üìÅ Parent directory for mount points
# BASE_STORAGE_PATH="$DEFAULT_BASE_STORAGE"

# ‚ö†Ô∏è  CRITICAL: First-Time Setup Requirements
# ================================================
# After installing this module, you MUST REBOOT once.
# 
# WHY? Magisk needs to establish the mount point directory
# structure during early boot. Without this, Android's storage
# layer will override permissions and cause read-only issues.
#
# AFTER THE FIRST REBOOT:
#   ‚úÖ Hotplugging works normally (no reboot needed)
#   ‚úÖ Drives auto-mount when plugged in
#   ‚úÖ Permissions are correct (media_rw group)
#
# BEFORE THE FIRST REBOOT:
#   ‚ùå Mount points may have wrong permissions
#   ‚ùå File managers may see "read-only" errors
# ================================================

# ‚ö†Ô∏è  Storage Path Limitations
# ================================================
# This module uses /storage/emulated/0/ext by default.
# 
# Android's storage layer (FUSE/sdcardfs) can interfere with
# permissions. To work around this:
#   1. We use Magisk's magic mount to pre-create directories
#   2. We set media_rw group (1023) + 2770 permissions
#   3. This mimics Android's native media folders
#
# If you still experience issues:
#   - Ensure you rebooted after installation
#   - Check logs: /data/local/tmp/mounter.log
#   - Try a root-enabled file manager
# ================================================

# ‚è±Ô∏è Refresh interval for auto-mount service (seconds)
# POLL_INTERVAL=5

# --- üíæ Saved Labels (Auto-generated by --scan or mount) ---
EOF
    fi
    
    # üîå Read the config into the current shell process.
    if [ -f "$config_file" ]; then
        source "$config_file"
    fi

    # üî• Use config value if provided, else fall back to script default.
    BASE_STORAGE="${BASE_STORAGE_PATH:-$DEFAULT_BASE_STORAGE}"
}

# üîó Link Bin: Creates a symlink for easy 'mounter' execution from anywhere.
link_bin() {
    local link_path="${1:-/system/bin/mounter}"
    local script_path=$(readlink -f "$0")

    log "Attempting to link $script_path to $link_path..."
    
    # üîì Try remounting /system as RW for linking (Required for some devices).
    if [[ "$link_path" == /system/* ]]; then
         run_cmd nsenter -t 1 -m -- mount -o remount,rw /system 2>/dev/null
    fi

    if run_cmd "$LN_BIN" -sf "$script_path" "$link_path"; then
        run_cmd "$CHMOD_BIN" +x "$link_path"
        log "Success! You can now run '${BOLD}$link_path${NC}' from anywhere."
    else
        error "Failed to create symlink. Try: $0 --link-bin /data/local/bin/mounter"
    fi
}

# ü§ñ Install Service: Creates a Magisk/KSU boot script for auto-mounting.
install_service() {
    local service_dir="/data/adb/service.d"
    local service_file="$service_dir/mount_block_device.sh"
    local script_path=$(readlink -f "$0")

    if [ ! -d "$service_dir" ]; then
        error "Service directory $service_dir not found. Are you using Magisk/KernelSU?"
        return 1
    fi

    log "Installing service to $service_file..."
    
    "$CAT_BIN" > "$service_file" <<EOF
#!/system/bin/sh
# üõ°Ô∏è Auto-generated by Android Mounter - Rex Ackermann
sleep 15
INTERVAL=\${POLL_INTERVAL:-5}
while true; do
    # üîÑ Periodically check and mount all devices.
    $script_path --all >> /data/local/tmp/mounter.log 2>&1
    sleep \$INTERVAL
done
EOF

    run_cmd "$CHMOD_BIN" +x "$service_file"
    log "Service installed! ‚ú® Reboot to start auto-mounting."
}

# --- üìÅ Mounting Logic Functions ---

# üßπ Cleanup: Audit all mounts and remove orphans from missing devices.
cleanup_stale_mounts() {
    # In AUTO_MODE, we only log if we actually find something to clean.
    local cleanup_done=0
    
    # 1Ô∏è‚É£ Check for active LUKS mappers with no backing block device.
    for mapper in /dev/mapper/luks_*; do
        [ ! -e "$mapper" ] && continue
        local mapper_name=$(basename "$mapper")
        # Ensure we check the status in the global context if needed
        local status=$("$CRYPTSETUP_BIN" status "$mapper_name" 2>/dev/null)
        local device=$(echo "$status" | grep "device:" | awk '{print $2}')
        
        if [ -n "$device" ] && [ ! -b "$device" ]; then
            [ $cleanup_done -eq 0 ] && log "Cleaning stale mounts... üßπ"
            log "Detected stale LUKS: $mapper_name (Device $device missing)"
            cleanup_done=1
            # Find any mount using this mapper in the GLOBAL namespace.
            local mnt_point=$($NSENTER_BIN -t 1 -m -- cat /proc/mounts | grep "$mapper" | awk '{print $2}' | head -n 1)
            [ -n "$mnt_point" ] && unmount_device "$(basename "$mnt_point")" || run_cmd "$CRYPTSETUP_BIN" close "$mapper_name"
        fi
    done

    # 2Ô∏è‚É£ Scan all mount points for block devices that no longer exist.
    $NSENTER_BIN -t 1 -m -- cat /proc/mounts | grep -E "/mnt/media_rw/|/storage/emulated/0/" | while read -r line; do
        local dev=$(echo "$line" | awk '{print $1}')
        local mnt=$(echo "$line" | awk '{print $2}')
        if [[ "$dev" == /dev/block/* ]] || [[ "$dev" == /dev/mapper/* ]]; then
            # If the device node is gone, it's definitely stale.
            if [ ! -e "$dev" ]; then
                [ $cleanup_done -eq 0 ] && log "Cleaning stale mounts... üßπ"
                log "Cleaning stale global mount: $mnt (Device $dev gone)"
                unmount_device "$(basename "$mnt")"
                cleanup_done=1
            fi
        fi
    done
}

# üîç Find Existing Mapper: Check if a device is already unlocked.
find_existing_mapper() {
    local dev=$1 ; [ -z "$dev" ] && return 1
    local real_target=$(readlink -f "$dev")
    
    for m_path in /dev/mapper/*; do
        [ ! -e "$m_path" ] || [ "$(basename "$m_path")" = "control" ] && continue
        local m_name=$(basename "$m_path")
        # Extract the source device from cryptsetup status
        local m_dev=$("$CRYPTSETUP_BIN" status "$m_name" 2>/dev/null | grep "device:" | awk '{print $2}')
        if [ -n "$m_dev" ]; then
            if [ "$(readlink -f "$m_dev")" = "$real_target" ]; then
                echo "$m_name" && return 0
            fi
        fi
    done
    return 1
}

# üß† Smart Driver Resolution: Map raw FS types to available kernel drivers.
resolve_fs_type() {
    local raw_type=$1
    local device=$2
    
    # Check what the kernel actually supports (global namespace)
    local k_support=$($NSENTER_BIN -t 1 -m -- cat /proc/filesystems)

    case "$raw_type" in
        ntfs)
            # Priority 1: Native Kernel Driver (ntfs3 - modern, fast)
            if echo "$k_support" | grep -q "ntfs3"; then
                echo "ntfs3"
            # Priority 2: Legacy Kernel Driver (ntfs - often read-only)
            elif echo "$k_support" | grep -q "ntfs"; then
                echo "ntfs"
            # Priority 3: Userspace Driver (ntfs-3g - robust, requires binary)
            elif [ -n "$NTFS3G_BIN" ]; then
                echo "ntfs-3g"
            else
                warn "NTFS detected on $device, but no driver found (ntfs3/ntfs kernel or ntfs-3g user)."
                warn "üí° Tip: Install ntfs-3g in Termux: pkg install ntfs-3g"
                echo "ntfs" # Fallback hope
            fi
            ;;
        exfat)
            # Modern kernels support exfat natively.
            if echo "$k_support" | grep -q "exfat"; then echo "exfat"; else echo "vfat"; fi ;;
        *)
            echo "$raw_type" ;;
    esac
}

# üì§ Unmounter: Safely detach storage and close encryption.
unmount_device() {
    local label=$1
    [ -z "$label" ] && error "Label is required." && return 1
    log "Unmounting $label from all namespaces..."

    # üîì 1. Kill all bindfs views for this label in the GLOBAL namespace.
    $NSENTER_BIN -t 1 -m -- cat /proc/mounts | grep "/storage/emulated/0/.*$label " | awk '{print $2}' | while read -r sp; do
        run_cmd nsenter -t 1 -m -- umount -l "$sp" && log "Detached user view: $sp"
    done

    # üìÅ 2. Unmount the physical hardware point in the GLOBAL namespace.
    local mnt_point="/mnt/media_rw/$label"
    if $NSENTER_BIN -t 1 -m -- mount | grep -q " $mnt_point "; then
        run_cmd nsenter -t 1 -m -- umount -l "$mnt_point" && log "Unmounted hardware: $mnt_point"
    fi

    # üîí 3. Seal the LUKS vault.
    for dev in /dev/mapper/luks_${label}_*; do
        [ -e "$dev" ] && log "Closing LUKS: $(basename "$dev")" && run_cmd "$CRYPTSETUP_BIN" close "$(basename "$dev")"
    done
}

# üìÇ Main Mounter: The core engine for unlocking, driver selection, and mounting.
mount_device() {
    local device=$1
    local label=$2
    
    # üõ°Ô∏è Safety: Skip internal storage and other non-target blocks.
    [ ! -b "$device" ] && return 1
    case "$device" in *mmcblk0*|*dm-*|*loop*) [ "$AUTO_MODE" != "1" ] && error "Safety: $device is internal." ; return 1 ;; esac

    # üö´ Blocklist Check: Stop infinite retries on dead drives.
    local dev_name=$(basename "$device")
    manage_failures "check" "$dev_name"
    if [ $? -ne 0 ]; then
        if [ "$AUTO_MODE" != "1" ]; then
             warn "Device $device is BLOCKED due to repeated failures. Re-plug to reset."
        fi
        return 1
    fi

    # üîã Device Health Check: Verify if the node is a "ghost" or unresponsive.
    local dev_name=$(basename "$device")
    if [ ! -r "/sys/class/block/$dev_name/size" ] || [ "$(cat "/sys/class/block/$dev_name/size" 2>/dev/null)" -eq 0 ]; then
        error "Device $device is unresponsive or has 0 size (Ghost Node)."
        warn "üí° Tip: Unplug and re-plug the drive to refresh the kernel state."
        return 1
    fi

    # üè∑Ô∏è Auto-label if none provided.
    [ -z "$label" ] && label=$(basename "$device")
    local mnt_point="/mnt/media_rw/$label"

    # üíæ Config Lookup: Find saved preferences using UUID.
    local uuid_check
    if ! uuid_check=$("$CRYPTSETUP_BIN" luksUUID "$device" 2>/dev/null); then 
        uuid_check=$("$BLKID_BIN" -o value -s UUID "$device" 2>/dev/null)
        [ -z "$uuid_check" ] && uuid_check=$(echo "$device" | tr '/' '_')
    fi
    local safe_uuid_check=$(echo "$uuid_check" | tr '-' '_')
    eval "saved_label_check=\${MAPPING_${safe_uuid_check}}"
    eval "saved_path_check=\${STORAGE_PATH_${safe_uuid_check}}"
    local target_label="${saved_label_check:-$label}"
    local target_storage="${saved_path_check:-$BASE_STORAGE/$target_label}"

    # ü§´ SMART-SKIP: Perform a silent health check to avoid redundant log spam.
    if $NSENTER_BIN -t 1 -m -- mount | grep -q " $mnt_point "; then
        if $NSENTER_BIN -t 1 -m -- mount | grep -q " $target_storage "; then
            if "$CRYPTSETUP_BIN" isLuks "$device" 2>/dev/null; then
                local current_mapper=$(find_existing_mapper "$device")
                if [ -n "$current_mapper" ] && $NSENTER_BIN -t 1 -m -- mount | grep -q "/dev/mapper/$current_mapper $mnt_point "; then
                    log "Health Check: $device ($target_label) is ${GREEN}Healthy & Active${NC} (LUKS) ‚úÖ"
                    return 0
                fi
            else
                if $NSENTER_BIN -t 1 -m -- mount | grep -q "^$device $mnt_point "; then
                    log "Health Check: $device ($target_label) is ${GREEN}Healthy & Active${NC} (Plain) ‚úÖ"
                    return 0 # ü§ê Healthy plain mount detected. Silent skip.
                fi
            fi
        fi
    fi

    # üö¶ Conflict Resolution: Clear occupied mount points if keys don't match.
    if $NSENTER_BIN -t 1 -m -- mount | grep -q " $mnt_point "; then
        local current_dev=$($NSENTER_BIN -t 1 -m -- mount | grep " $mnt_point " | awk '{print $1}')
        local conflict=1
        
        # ü§ù Smart Sync: Check if the "conflicting" device is actually our target (alias).
        if [[ "$current_dev" == /dev/mapper/* ]]; then
             local m_name=$(basename "$current_dev")
             local real_backend=$("$CRYPTSETUP_BIN" status "$m_name" 2>/dev/null | grep "device:" | awk '{print $2}')
             local real_target=$(readlink -f "$device")
             if [ -n "$real_backend" ] && [ "$(readlink -f "$real_backend")" = "$real_target" ]; then
                 log "Smart Sync: $mnt_point is correctly mounted by alias $m_name. ‚úÖ"
                 conflict=0
             fi
        fi

        if [ "$current_dev" = "$device" ] || [[ "$current_dev" == /dev/mapper/luks_${label}_* ]]; then
             conflict=0
        fi

        if [ $conflict -eq 0 ]; then
             warn "$mnt_point is already correctly mounted." && return 0
        else
            log "Conflict: $mnt_point is occupied by $current_dev. Clearing..."
            unmount_device "$label"
        fi
    fi
    
    # üîì LUKS Detection & Decoding.
    local existing_mapper=$(find_existing_mapper "$device")
    local unlocked=0
    local mapper_name=""
    local uuid
    local IS_LUKS=0

    # 1. Check if it's already a LUKS device.
    if "$CRYPTSETUP_BIN" isLuks "$device" 2>/dev/null; then
        IS_LUKS=1
        log "LUKS header detected on $device."
        
        # ‚ö° Pass 1 Safety: If we mistakenly entered here during Pass 1, ABORT.
        # This prevents interactive password prompts from blocking the loop.
        if [ "${PASS:-0}" -eq 1 ]; then
            warn "Pass 1: Skipping LUKS device $device to prevent blocking. üõë"
            return 0
        fi
    fi

    if [ -n "$existing_mapper" ]; then
        log "Device $device is already open as $existing_mapper"
        # üß™ Check if this existing mapper is actually MOUNTED in global namespace.
        if $NSENTER_BIN -t 1 -m -- mount | grep -q "^/dev/mapper/$existing_mapper "; then
             log "$existing_mapper is active and mounted. Reusing existing link."
             mapper_name="$existing_mapper" ; unlocked=1
        else
             log "$existing_mapper is active but UNMOUNTED. Closing stale link to reset."
             run_cmd "$CRYPTSETUP_BIN" close "$existing_mapper"
             existing_mapper=""
        fi
    fi

    # 2. Extract UUID (Critical for key mapping).
    if [ $IS_LUKS -eq 1 ]; then
        uuid=$("$CRYPTSETUP_BIN" luksUUID "$device" 2>/dev/null)
        if [ -z "$uuid" ]; then
            error "Could not read LUKS UUID. Device might be busy or unstable."
            warn "Attempting to continue as plain partition (Risk of data loss!)..."
            IS_LUKS=0
        fi
    fi

    if [ $IS_LUKS -eq 0 ]; then
         uuid=$("$BLKID_BIN" -o value -s UUID "$device" 2>/dev/null)
         [ -z "$uuid" ] && uuid=$(echo "$device" | tr '/' '_')
         log "Plain device detected. UUID: $uuid"
    else
         log "Locked LUKS UUID: $uuid"
    fi

    # üíæ Config Lookup: Restore saved label and path.
    local safe_uuid=$(echo "$uuid" | tr '-' '_')
    eval "saved_label=\${MAPPING_${safe_uuid}}"
    eval "saved_storage_path=\${STORAGE_PATH_${safe_uuid}}"
    
    # If a saved label exists, use it (especially in Auto Mode).
    [ -n "$saved_label" ] && ( [ -z "$label" ] || [ "$AUTO_MODE" = "1" ] ) && label="$saved_label"
    local storage_point="${saved_storage_path:-$BASE_STORAGE/$label}"

    # üß† Mapper Identification.
    if [ $IS_LUKS -eq 1 ]; then
        if [ $unlocked -eq 0 ]; then
            local rand_suffix=$(head -n 1 /dev/urandom | tr -dc 'a-f0-9' | head -c 6)
            mapper_name="luks_${label}_${rand_suffix}"
        fi
        TARGET_DEV="/dev/mapper/$mapper_name"
    else
        unlocked=1 ; TARGET_DEV="$device"
    fi

    # üîë Auto-Unlock Sequence (LUKS Only).
    local keyfile="$KEY_DIR/$uuid.key"
    eval "defined_key=\${KEY_PATH_${safe_uuid}}"

    # 1. Configured keyfile
    if [ $unlocked -eq 0 ] && [ -n "$defined_key" ] && [ -f "$defined_key" ]; then
        log "Trying defined key: $defined_key"
        run_cmd "$CRYPTSETUP_BIN" open "$device" "$mapper_name" --key-file "$defined_key" && unlocked=1
    fi

    # 2. Standard UUID-based keyfile
    if [ $unlocked -eq 0 ] && [ -f "$keyfile" ]; then
        run_cmd "$CRYPTSETUP_BIN" open "$device" "$mapper_name" --key-file "$keyfile" && unlocked=1
    fi

    # 3. üïµÔ∏è Brute-force key directory
    if [ $unlocked -eq 0 ]; then
        for k in "$KEY_DIR"/*; do
            [ ! -f "$k" ] || [ "$k" = "$keyfile" ] || [ "$k" = "$defined_key" ] || [ "$(basename "$k")" = "config" ] && continue
            run_cmd "$CRYPTSETUP_BIN" open "$device" "$mapper_name" --key-file "$k" && unlocked=1 && break
        done
    fi

    # 4. Interactive Password (Keyboard)
    if [ $unlocked -eq 0 ]; then
        log "Manual unlock needed for $device:"
        echo " 1) Password (default) | 2) Select Keyfile | s) Skip"
        read -r unlock_opt
        case "$unlock_opt" in
            2) printf "Keyfile path: " ; read -r mk ; [ -f "$mk" ] && run_cmd "$CRYPTSETUP_BIN" open "$device" "$mapper_name" --key-file "$mk" && unlocked=1 ;;
            s|S) return 1 ;;
            *) log "Password for $device:" ; stty -echo ; read -r PASS ; stty echo ; echo "" 
               # üõ°Ô∏è Aggressive conflict resolution: If opening fails due to "in use", try to find who is using it.
               if ! echo -n "$PASS" | run_cmd "$CRYPTSETUP_BIN" open "$device" "$mapper_name"; then
                   warn "$device reports 'already in use'. Re-scanning for ghosts..."
                   local ghost=$(find_existing_mapper "$device")
                   if [ -n "$ghost" ]; then
                       log "Found orphan mapper: $ghost. Closing..."
                       run_cmd "$CRYPTSETUP_BIN" close "$ghost"
                       echo -n "$PASS" | run_cmd "$CRYPTSETUP_BIN" open "$device" "$mapper_name" && unlocked=1
                   else
                       error "Failed to open $device."
                   fi
               else
                   unlocked=1
               fi
               [ $unlocked -eq 0 ] && { 
                   error "Unlock failed." 
                   local dev_tag="AndroidMounter_$(basename "$device")"
                   send_notification "Android Mounter" "Unlock Failed for $(basename "$device") üîí" "$dev_tag"
                   unset PASS ; return 1 
               } 
               ;;
        esac
        # üîë Offer to save this as a keyfile for next time.
        if [ $unlocked -eq 1 ]; then
            log "Successfully unlocked! ‚ú®"
            echo "Save new keyfile for auto-unlock? [y/N]" ; read -r sk
            if [ "$sk" = "y" ]; then
                dd if=/dev/urandom of="$keyfile" bs=512 count=1 >/dev/null 2>&1 ; chmod 600 "$keyfile"
                [ -n "$PASS" ] && echo -n "$PASS" | run_cmd "$CRYPTSETUP_BIN" luksAddKey "$device" "$keyfile" || run_cmd "$CRYPTSETUP_BIN" luksAddKey "$device" "$keyfile"
            fi
        fi ; unset PASS
    fi

    # üîç Nested Partition Scan (Recursive).
    # LUKS Containers often act as virtual disks containing their own partition tables.
    if [[ "$TARGET_DEV" == /dev/mapper/* ]]; then
        # Force kernel re-scan
        run_cmd blockdev --rereadpt "$TARGET_DEV" 2>/dev/null
        
        local has_partitions=0
        for part in "${TARGET_DEV}"* "${TARGET_DEV}"p*; do
             [ ! -b "$part" ] || [ "$part" = "$TARGET_DEV" ] && continue
             
             if [ $has_partitions -eq 0 ]; then
                 log "Detected partitions inside LUKS container. Switching to recursive mode... üì¶"
                 has_partitions=1
             fi
             log "Processing nested partition: $part"
             # Recursively mount the inner partitions
             mount_device "$part" ""
        done
        # If partitions processed, parent is done.
        [ $has_partitions -eq 1 ] && log "Recursive processing complete for $device." && return 0 
    fi

    # Create filesystem mount point
    [ ! -d "$mnt_point" ] && run_cmd "$MKDIR_BIN" -p "$mnt_point" && run_cmd "$CHMOD_BIN" 0775 "$mnt_point" && run_cmd "$CHOWN_BIN" root:1023 "$mnt_point"
    
    MOUNTED=0
    local NS_ENV="env PATH=$PATH LD_LIBRARY_PATH=$LD_LIBRARY_PATH LD_PRELOAD=$LD_PRELOAD"
    
    # üö´ Explicit Skip: BTRFS 
    local raw_fs=$("$BLKID_BIN" -o value -s TYPE "$TARGET_DEV")
    if [ "$raw_fs" = "btrfs" ]; then
        warn "Skipping BTRFS device $device (Explicitly ignored). üå≤üö´"
        # Return 1 to trigger blocklist failure counting.
        return 1
    fi

    # 1. Primary: Smart Type Detection & Driver Selection
    local best_fs=$(resolve_fs_type "$raw_fs" "$TARGET_DEV")
    
    if [ -n "$best_fs" ]; then
        # ü©π Auto-Fix: NTFS Dirty Bit
        if [[ "$best_fs" == "ntfs"* ]] && [ -x "$NTFSFIX_BIN" ]; then
             log "Running ntfsfix to clear dirty flags..."
             run_cmd nsenter -t 1 -m -- $NS_ENV "$NTFSFIX_BIN" -d "$TARGET_DEV"
        fi

        if [ "$best_fs" = "ntfs-3g" ] && [ -n "$NTFS3G_BIN" ]; then
             log "Mounting with NTFS-3G (Userspace)..."
             run_cmd nsenter -t 1 -m -- $NS_ENV "$NTFS3G_BIN" "$TARGET_DEV" "$mnt_point" && MOUNTED=1
        else
             log "Mounting with driver: ${BOLD}$best_fs${NC}..."
             run_cmd nsenter -t 1 -m -- $NS_ENV "$MOUNT_BIN" -t "$best_fs" "$TARGET_DEV" "$mnt_point" && MOUNTED=1
        fi
    fi

    # 2. Fallback: Generic Auto-detect
    [ $MOUNTED -eq 0 ] && run_cmd nsenter -t 1 -m -- $NS_ENV "$MOUNT_BIN" "$TARGET_DEV" "$mnt_point" && MOUNTED=1
    
    # 3. Kernel Brute-force: Try all filesystems
    [ $MOUNTED -eq 0 ] && for fs in $(cat /proc/filesystems | grep -v "nodev" | awk '{print $2}'); do
        run_cmd nsenter -t 1 -m -- $NS_ENV "$MOUNT_BIN" -t "$fs" "$TARGET_DEV" "$mnt_point" >/dev/null 2>&1 && MOUNTED=1 && break
    done

    # ‚ùå Handling Mount Failure
    if [ $MOUNTED -eq 0 ]; then
        error "Mount failed."
        local dev_tag="AndroidMounter_$(basename "$device")"
        send_notification "Android Mounter" "Mount Failed for $(basename "$device") üí•" "$dev_tag"
        
        # üõ°Ô∏è Track Failure: This stops infinite loops for dead/unsupported drives.
        manage_failures "add" "$(basename "$device")"
        [ -n "$mapper_name" ] && run_cmd "$CRYPTSETUP_BIN" close "$mapper_name"
        return 1
    fi

    # ‚úÖ Handling Success & Verification.
    log_msg="Successfully mounted $device at $mnt_point"
    if [ $MOUNTED -eq 1 ]; then
        # üß™ Integrity Verification: Check for "Ghost" Mounts (I/O Errors)
        if ! $NSENTER_BIN -t 1 -m -- ls -1q "$mnt_point" >/dev/null 2>&1; then
             error "Mount verification failed: I/O Error detected! üö´"
             warn "Unmounting unstable device..."
             unmount_device "$label"
             
             local dev_tag="AndroidMounter_$(basename "$device")"
             send_notification "Android Mounter" "I/O Error: Unstable Mount ($dev_name) ‚ö†Ô∏è" "$dev_tag"
             manage_failures "add" "$dev_name"
             return 1
        fi
        
        # üéâ Passed: Reset failure count.
        manage_failures "reset" "$dev_name"
        log "${GREEN}$log_msg${NC}"
        
        # üîó Bindfs User View (Global NS).
        log "Creating user-visible bindfs view at $target_storage..."
        [ ! -d "$target_storage" ] && run_cmd "$MKDIR_BIN" -p "$target_storage"
        
        # ü©π Bindfs Safe Mode (Strip LD_PRELOAD)
        local BINDFS_ENV="env PATH=$PATH LD_LIBRARY_PATH=$LD_LIBRARY_PATH"
        
        # üéØ ANDROID MEDIA STORAGE PATTERN
        # Mimic native Android media folders (like Podcasts, Music, etc.)
        # Owner: Termux (so you can access via shell)
        # Group: media_rw (1023) - Android's media access group
        # Perms: rwxrws--- (0770 + setgid) - Group write + setgid bit
        # The setgid ensures new files inherit the media_rw group
        run_cmd nsenter -t 1 -m -- $BINDFS_ENV "$BINDFS_BIN" \
            -u "$TERMUX_UID" \
            -g 1023 \
            --perms=0770 \
            --create-with-perms=g+s \
            "$mnt_point" "$target_storage"
        
        # üß™ User View Verification
        if ! $NSENTER_BIN -t 1 -m -- ls -1q "$target_storage" >/dev/null 2>&1; then
             warn "Bindfs view unstable (I/O Error). Detaching..."
             run_cmd nsenter -t 1 -m -- "$UMOUNT_BIN" -l "$target_storage"
             
             # Try 2: Fallback to standard bind mount
             log "Fallback: Creating standard bind mount (ownership mapping disabled)..."
             run_cmd nsenter -t 1 -m -- mount --bind "$mnt_point" "$target_storage"
             
             if ! $NSENTER_BIN -t 1 -m -- ls -1q "$target_storage" >/dev/null 2>&1; then
                  error "Fallback mount also failed. User view unavailable."
                  send_notification "Android Mounter" "User View Failed for $(basename "$device") ‚ö†Ô∏è" "$dev_tag"
             else
                  log "Fallback active: ${YELLOW}Access OK (Root owned)${NC}"
                  send_notification "Android Mounter" "Mounted (Fallback Mode) on $target_storage" "$dev_tag"
                  log "Success! üéä Your drive is now at: ${BOLD}$target_storage${NC}"
             fi
        else
             # üîî Notify User (Success)
             local n_type="Drive"
             [ $IS_LUKS -eq 1 ] && n_type="Secure Drive"
             send_notification "Android Mounter" "Mounted $n_type ($(basename "$device")) on $target_storage" "$dev_tag"
             
             # ‚ö†Ô∏è Storage Path Warning
             if [[ "$target_storage" == /storage/emulated/0/* ]]; then
                 warn "‚ö†Ô∏è  NOTICE: Mounted to /storage/emulated/0/ path."
                 warn "If you experience permission issues with file managers:"
                 warn "  1. Try /data/media/0/ instead (edit config file)"
                 warn "  2. Or use a root-enabled file manager"
                 warn "See config for details: $KEY_DIR/config"
             fi
             
             # üíæ Update config with successful mapping.
             if [ "$AUTO_MODE" != "1" ]; then
                 save_config_label "$uuid" "$label" "$device"
             fi
             log "Success! üéä Your drive is now at: ${BOLD}$target_storage${NC}"
        fi
    else
        warn "Bindfs failed. Detaching..." ; run_cmd nsenter -t 1 -m -- "$UMOUNT_BIN" "$mnt_point"
        [ -n "$mapper_name" ] && run_cmd "$CRYPTSETUP_BIN" close "$mapper_name" ; return 1
    fi
}

# üì° Scanner: Discover and register all connected partitions.
scan_all_devices() {
    log "Scanning all partitions... üì°"
    local added=0
    for dev in $(ls /dev/block/sd* /dev/block/mmcblk1* 2>/dev/null); do
        case "$(basename "$dev")" in sd[a-z]|mmcblk1) ls "${dev}"[0-9]* >/dev/null 2>&1 || ls "${dev}"p[0-9]* >/dev/null 2>&1 && continue ;; esac
        local uuid
        if ! uuid=$("$CRYPTSETUP_BIN" luksUUID "$dev" 2>/dev/null); then uuid=$("$BLKID_BIN" -o value -s UUID "$dev" 2>/dev/null) ; [ -z "$uuid" ] && uuid=$(echo "$dev" | tr '/' '_') ; fi
        local label=$("$BLKID_BIN" -o value -s LABEL "$dev" 2>/dev/null) ; [ -z "$label" ] && label=$(basename "$dev")
        save_config_label "$uuid" "$label" "$dev" && added=$((added + 1))
    done
    log "Scan complete. Added $added new device entries! ‚ú®"
}

# üíæ Config Persistence: Save device-to-label mappings safely.
save_config_label() {
    local uuid="$1" ; local label="$2" ; local dev_path="$3" ; local config_file="$KEY_DIR/config"
    [ ! -f "$config_file" ] && return 1
    local safe_uuid=$(echo "$uuid" | tr '-' '_')
    grep -q "MAPPING_${safe_uuid}=" "$config_file" && return 1
    log "Mapping $label to $uuid... üíæ"
    local type="OTG" ; [[ "$dev_path" == *mmcblk* ]] && type="MMC"
    echo -e "\n# --- $type Device: $uuid ---" >> "$config_file"
    echo "MAPPING_${safe_uuid}=\"$label\"" >> "$config_file"
    echo "STORAGE_PATH_${safe_uuid}=\"$BASE_STORAGE/$label\"" >> "$config_file"
    echo "# KEY_PATH_${safe_uuid}=\"\"" >> "$config_file"
    return 0
}

# üõ°Ô∏è Failure Manager: Track strikes against unstable devices.
manage_failures() {
    local action=$1
    local dev_name=$2
    [ ! -d "$FAILURE_TRACKING_DIR" ] && mkdir -p "$FAILURE_TRACKING_DIR"
    local track_file="$FAILURE_TRACKING_DIR/$dev_name"

    case "$action" in
        check)
            # If device node is gone, reset immediately (Re-plug detection).
            if [ ! -e "/dev/block/$dev_name" ]; then
                rm -f "$track_file"
                return 0
            fi
            
            if [ -f "$track_file" ]; then
                local count=$(cat "$track_file")
                # Strict Limit: 2 strikes -> Blocked.
                if [ "$count" -ge 2 ]; then
                    return 1 # Blocked
                fi
            fi
            return 0
            ;;
        add)
            local count=0
            [ -f "$track_file" ] && count=$(cat "$track_file")
            count=$((count + 1))
            echo "$count" > "$track_file"
            warn "Failure strike $count/2 for $dev_name"
            if [ "$count" -ge 2 ]; then
                error "üö´ Device $dev_name is now BLOCKED. Unplug to reset."
            fi
            ;;
        reset)
            [ -f "$track_file" ] && rm "$track_file"
            ;;
    esac
}

# üìã Status Dashboard: Top-down view of all monitored storage.
show_status() {
    echo -e "\n${BOLD}${CYAN}üìä Storage Status Dashboard${NC}"
    printf "${BOLD}%-15s %-12s %-10s %-20s %-20s${NC}\n" "Device" "Type" "Encryption" "Mount Point" "User View"
    echo "------------------------------------------------------------------------------------------------"
    
    local TMP_LIST=$(mktemp)
    for dev in $(ls /dev/block/sd* /dev/block/mmcblk1* 2>/dev/null); do
        case "$(basename "$dev")" in sd[a-z]|mmcblk1) ls "${dev}"[0-9]* >/dev/null 2>&1 || ls "${dev}"p[0-9]* >/dev/null 2>&1 && continue ;; esac
        echo "$dev" >> "$TMP_LIST"
    done

    while IFS= read -r dev; do
        local name=$(basename "$dev")
        local type="OTG" ; [[ "$dev" == *mmcblk1* ]] && type="SD"
        
        # 1. Encryption Check
        local enc_state="Plain"
        local enc_color="" 
        local mapper=$(find_existing_mapper "$dev")
        if [ -n "$mapper" ]; then 
            enc_state="Unlocked" ; enc_color="$GREEN"
        elif "$CRYPTSETUP_BIN" isLuks "$dev" 2>/dev/null; then 
            enc_state="Locked" ; enc_color="$RED"
        fi
        
        # 2. Hardware Mount Check
        local hw_mnt=$($NSENTER_BIN -t 1 -m -- mount | grep "^$dev \|^/dev/mapper/luks_" | grep "$dev" | awk '{print $3}' | head -n 1)
        local hw_txt="-"
        local hw_color="$NC"
        if [ -n "$hw_mnt" ]; then hw_txt="$hw_mnt" ; hw_color="$CYAN" ; fi
        
        # 3. User View Check
        local user_view=$($NSENTER_BIN -t 1 -m -- cat /proc/mounts | grep "bindfs" | grep "$(basename "$dev")" | awk '{print $2}' | head -n 1)
        local user_txt="-"
        local user_color="$NC"
        if [ -n "$user_view" ]; then user_txt="$user_view" ; user_color="$BLUE" ; else user_color="$RED" ; fi
        
        printf "%-15s %-12s ${enc_color}%-12s${NC} ${hw_color}%-35s${NC} ${user_color}%s${NC}\n" "$name" "$type" "$enc_state" "$hw_txt" "$user_txt"
    done < "$TMP_LIST"
    rm "$TMP_LIST"
    echo ""
}

# --- üöÄ Main Execution Block ---

SESSION_ID=$(date +%s)_$((RANDOM % 1000))
log "Starting Android LUKS Mounter v1.5.31-BINDFS-FIX ‚ú®"
log "Session ID: $SESSION_ID"
log "Executing from: $(readlink -f "$0")"

# 1Ô∏è‚É£ Load user settings first.
[ ! -d "$KEY_DIR" ] && "$MKDIR_BIN" -p "$KEY_DIR"
load_config
check_tools

MODE="mount" ; AUTO_MODE="0" ; DEVICE="" ; LABEL=""

# 2Ô∏è‚É£ Parse command line arguments.
while [ $# -gt 0 ]; do
    case "$1" in
        -h|--help) usage ;;
        --install-service) MODE="install_service" ; shift ;;
        --link-bin) MODE="link_bin" ; shift ; [ -n "$1" ] && [[ "$1" != -* ]] && LINK_PATH="$1" && shift ;;
        -u|--unmount) MODE="unmount" ; shift ;;
        --all) MODE="mount" ; AUTO_MODE="1" ; shift ;;
        --scan) MODE="scan" ; shift ;;
        -s|--status) MODE="status" ; shift ;;
        --auto-update-config) MODE="auto_update" ; AUTO_MODE="1" ; shift ;;
        *) [ -z "$DEVICE" ] && [ "$MODE" != "unmount" ] && DEVICE="$1" || LABEL="$1" ; shift ;;
    esac
done

# 3Ô∏è‚É£ Dispatch to the appropriate mode.
case "$MODE" in
    status) show_status ; exit 0 ;;
    install_service) install_service ; exit 0 ;;
    link_bin) link_bin "$LINK_PATH" ; exit 0 ;;
    unmount) [ -z "$LABEL" ] && [ -n "$DEVICE" ] && LABEL="$DEVICE" ; unmount_device "$LABEL" ; exit 0 ;;
    scan) scan_all_devices ; exit 0 ;;
    auto_update) log "Auto-updating config... üîÑ" ; scan_all_devices ; ;;
esac

# 4Ô∏è‚É£ Handle Mounting (Auto or Manual).
if [ "$AUTO_MODE" = "1" ]; then
    log "Engaging auto-mount mode... ‚ö°" ; cleanup_stale_mounts
    
    # ‚ö° Pass 1: Mount FAST plain devices first (Instant access)
    # The 'PASS=1' variable tells mount_device() to ABORT if it sees a LUKS device.
    # This prevents the script from stopping to ask for a password.
    log "Pass 1: Mounting plain devices... üöÄ"
    PASS=1
    for dev in $(ls /dev/block/sd* /dev/block/mmcblk1* 2>/dev/null); do
        case "$(basename "$dev")" in sd[a-z]|mmcblk1) ls "${dev}"[0-9]* >/dev/null 2>&1 || ls "${dev}"p[0-9]* >/dev/null 2>&1 && continue ;; esac
        # Optimistic check: If cryptsetup says it's NOT luks, go ahead.
        if ! "$CRYPTSETUP_BIN" isLuks "$dev" 2>/dev/null; then
             mount_device "$dev" ""
        fi
    done

    # üîê Pass 2: Mount LUKS devices (Potential interaction/slow)
    # Now we allow password prompts and decryption.
    log "Pass 2: Mounting LUKS devices... üõ°Ô∏è"
    PASS=2
    for dev in $(ls /dev/block/sd* /dev/block/mmcblk1* 2>/dev/null); do
        case "$(basename "$dev")" in sd[a-z]|mmcblk1) ls "${dev}"[0-9]* >/dev/null 2>&1 || ls "${dev}"p[0-9]* >/dev/null 2>&1 && continue ;; esac
        # We process it if it IS luks.
        if "$CRYPTSETUP_BIN" isLuks "$dev" 2>/dev/null; then
             mount_device "$dev" ""
        fi
    done
else
    # Manual Mount: Requires at least a device path.
    [ -z "$DEVICE" ] && usage
    mount_device "$DEVICE" "$LABEL"
fi

################################################################################
# üèÅ Created with ‚ù§Ô∏è by Rex Ackermann                                          #
################################################################################
